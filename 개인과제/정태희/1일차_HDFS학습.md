# HDFS

### **구조**

- 마스터 슬레이브 구조
- 하나의 네임노드와 여러 개의 데이터노드로 구성
- 네임노드는 메타데이터를 가지고 있고, 데이터는 블록 단위로 나누어 데이터노드에 저장
- 사용자는 네임노드를 이용해 데이터를 쓰고, 읽을 수 있다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5b0f6fad-5eec-4344-8f21-2ff47ccaee44/Untitled.png)

---

## **네임노드**

- 주요 역할
    - 메타데이터 관리
    - 데이터노드의 관리

### ****메타데이터 관리****

- 메타데이터
    - 파일이름, 파일크기, 파일생성시간, 파일접근권한, 파일 소유자 및 그룹 소유자, 파일이 위치한 블록의 정보 등으로 구성
    - 각 데이터노드에서 전달하는 메타데이터를 받아서 전체 노드의 메타데이터 정보와 파일 정보를 묶어서 관리
- 메타데이터는 사용자가 설정한 위치(dfs.name.dir)에 보관
- 네임노드가 실행 될 때 파일을 읽어서 메모리에 보관
- 운영중에 발생한 수정사항은 네임노드의 메모리에는 바로 적용되고, 데이터의 수정사항을 다음 구동시 적용을 위해서 주기적으로 Edist 파일로 저장

### **메타데이터 파일 종류**

- Fsimage 파일
    - 네임스페이스와 블록 정보
- Edits 파일
    - 파일의 생성, 삭제에 대한 트랜잭션 로그
    - 메모리에 저장하다가 주기적으로 생성

### **메타데이터 파일 저장 형태**

- 사용자가 설정한 위치(dfs.name.dir)에 다음과 같은 파일의 형태로 저장

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/62e54846-eb3e-42b9-9805-7c1b8718e8a0/Untitled.png)

- VERSION: 현재 실행 중인 HDFS의 ID, 타입 등 정보
- edits_0000xxx-0000xxx: 트랜잭션 정보. edits_트랜잭션시작번호-트랜잭션종료번호 까지의 정보를 저장
- eidts_inprogress_000xx: 최신 트랜잭션 정보. 압축되지 않은 정보
- fsimage_000xxx: 000xxx 까지 트랜잭션 정보가 처리된 fsimage
- fsimage_000xxx.md5: fsiamge의 해쉬값
- seen_txid: 현재 트랜잭션 ID

### **데이터 노드 관리**

- 데이터노드가 주기적으로 전달하는 하트비트(3초, `dfs.heartbeat.interval`)와 블록리포트(6시간, `dfs.blockreport.intervalMsec`)를 이용하여 데이터 노드의 동작상태, 블록상태를 관리
- 하트비트가 도착하지 않으면 네임노드는 데이터노드가 동작 하지 않는 것으로 간주하고, 더이상 IO 가 발생하지 않도록 조치
- 블록리포트
    - HDFS에 저장된 파일에 대한 최신 정보를 유지
    - 데이터노드에 저장된 블록 목록과 각 볼록이 로컬 디스크의 어디에 저장되어 있는지에 대한 정보

---

## **데이터노드**

- 파일을 저장하는 역할
- 파일은 블록단위로 저장
- 주기적으로 네임노드에 하트비트와 블록리포트를 전달
    - 하트비트는 데이타노드의 동작여부를 판단
        - 네임노드는 하트비트가 전달되지 않는 데이터노드는 동작하지 않는 것으로 판단, 더이상 데이터를 저장하지 않도록 설정
    - 블록리포트로 블록의 변경사항을 체크하고, 네임노드의 메타데이터를 갱신

### **블록 파일 저장형태**

- 사용자가 설정한 위치(dfs.data.dir)에 다음과 같은 파일의 형태로 저장
- 블록은 블록과 블록의 메타 정보로 저장됩니다.
- blk_12345
    - 파일 블록
    - 최대 크기가 블록 사이즈(dfs.blocksize) 크기로 생성
    - 블록 복제 개수에 따라 동일한 이름의 블록이 여러 개의 노드에 생성 됨
- blk_12345_29082353.meta
    - 블록의 메타 정보

```bash
./hdfs/current/BP-11233441/current/finalized/subdir187/subdir191:
total 676K
drwxr-xr-x   2 hdfs hdfs 4.0K Sep  8 04:30 .
drwxr-xr-x 258 hdfs hdfs 8.0K Aug 31 22:21 ..
-rw-r--r--   1 hdfs hdfs  40K Aug 31 22:46 blk_12345
-rw-r--r--   1 hdfs hdfs  327 Aug 31 22:46 blk_12345_29082353.meta
-rw-r--r--   1 hdfs hdfs  19K Aug 31 22:46 blk_12346
-rw-r--r--   1 hdfs hdfs  155 Aug 31 22:46 blk_12346_29082375.meta
-rw-r--r--   1 hdfs hdfs 262K Aug 31 22:46 blk_12347
-rw-r--r--   1 hdfs hdfs 2.1K Aug 31 22:46 blk_12347_29082433.meta

```

### **데이타노드 상태**

- 데이터 노드의 상태를 나타내는 정보는 두 가지로 구분
    - 활성 상태
        - 데이터노드가 Live 상태인지 Dead 상태인지를 나타냄
        - 데이터노드가 하트비트를 주기적으로 전달하여 살아 있는지 확인되면 Live 상태
        - 데이터노드에 문제가 발생하여 지정한 시간동안(`dfs.namenode.stale.datanode.interval`)하트비트를 받지 못하면 네임노드는 데이터노드의 상태를 Stale 상태로 변경, 이후 지정한 시간동안 응답이 없으면 Dead 노드로 변경
    - 운영 상태
        - 운영 상태는 데이터노드의 업그레이드, 패치 같은 작업을 하기 위해 서비스를 잠시 멈추어야 할 경우 블록을 안전하게 보관하기 위해 설정
        - NORMAL: 서비스 상태
        - DECOMMISSIONED: 서비스 중단 상태
        - DECOMMISSION_INPROGRESS: 서비스 중단 상태로 진행 중
        - IN_MAINTENANCE: 정비 상태
        - ENTERING_MAINTENANCE: 정비 상태로 진행 중

---

## **네임노드 구동 과정**

- Fsimage와 Edits를 읽어서 작업을 처리하기 때문에 두 파일의 크기가 크면 구동 시작시간이 오래 걸릴 수 있음
- Fsimage를 읽어 메모리에 적재, Edits 파일을 읽어와서 변경내역을 반영
- 현재의 메모리 상태를 스냅샷으로 생성하여 Fsimage 파일 생성데이터 노드로부터 블록리포트를 수신하여 매핑정보 생성

---

## **파일 읽기/쓰기**

- HDFS의 파일에 접근하는 가장 간단한 방법은 HDFS 명령행 인터페이스를 이용하는 것
- Java, C API를 제공하여 이를 구현해서 접근

### **파일 읽기**

1. 네임노드에 파일이 보관된 블록 위치 요청
2. 네임노드가 블록 위치 반환
3. 각 데이터 노드에 파일 블록을 요청
    - 노드의 블록이 깨져 있으면 네임노드에 이를 통지하고 다른 블록 확인

!https://wikidocs.net/images/page/23582/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-01-10_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_10.41.49.png

## **파일 쓰기**

1. 네임노드에 파일 정보를 전송하고, 파일의 블록을 써야할 노드 목록 요청
2. 네임노드가 파일을 저장할 목록 반환
3. 데이터 노드에 파일 쓰기 요청
    - 데이터 노드간 복제가 진행
